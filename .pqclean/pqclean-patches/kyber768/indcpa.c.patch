--- work/kyber768/scheme/indcpa.c
+++ work-patched/kyber768/scheme/indcpa.c
@@ -59,12 +59,12 @@
 **************************************************/
 static void pack_pk(uint8_t r[KYBER_INDCPA_PUBLICKEYBYTES],
                     int16_t pk[KYBER_K][KYBER_N],
-                    const uint8_t seed[KYBER_SYMBYTES])
-{
-  size_t i;
-  polyvec_tobytes(r, pk);
-  for(i=0;i<KYBER_SYMBYTES;i++)
-    r[i+KYBER_POLYVECBYTES] = seed[i];
+                    const uint8_t seed[KYBER_SYMBYTES]) {
+    size_t i;
+    polyvec_tobytes(r, pk);
+    for (i = 0; i < KYBER_SYMBYTES; i++) {
+        r[i + KYBER_POLYVECBYTES] = seed[i];
+    }
 }
 
 /*************************************************
@@ -79,12 +79,12 @@
 **************************************************/
 static void unpack_pk(int16_t pk[KYBER_K][KYBER_N],
                       uint8_t seed[KYBER_SYMBYTES],
-                      const uint8_t packedpk[KYBER_INDCPA_PUBLICKEYBYTES])
-{
-  size_t i;
-  polyvec_frombytes(pk, packedpk);
-  for(i=0;i<KYBER_SYMBYTES;i++)
-    seed[i] = packedpk[i+KYBER_POLYVECBYTES];
+                      const uint8_t packedpk[KYBER_INDCPA_PUBLICKEYBYTES]) {
+    size_t i;
+    polyvec_frombytes(pk, packedpk);
+    for (i = 0; i < KYBER_SYMBYTES; i++) {
+        seed[i] = packedpk[i + KYBER_POLYVECBYTES];
+    }
 }
 
 /*************************************************
@@ -95,9 +95,8 @@
 * Arguments:   - uint8_t *r: pointer to output serialized secret key
 *              - polyvec *sk: pointer to input vector of polynomials (secret key)
 **************************************************/
-static void pack_sk(uint8_t r[KYBER_INDCPA_SECRETKEYBYTES], int16_t sk[KYBER_K][KYBER_N])
-{
-  polyvec_tobytes(r, sk);
+static void pack_sk(uint8_t r[KYBER_INDCPA_SECRETKEYBYTES], int16_t sk[KYBER_K][KYBER_N]) {
+    polyvec_tobytes(r, sk);
 }
 
 /*************************************************
@@ -108,9 +107,8 @@
 * Arguments:   - polyvec *sk: pointer to output vector of polynomials (secret key)
 *              - const uint8_t *packedsk: pointer to input serialized secret key
 **************************************************/
-static void unpack_sk(int16_t sk[KYBER_K][KYBER_N], const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES])
-{
-  polyvec_frombytes(sk, packedsk);
+static void unpack_sk(int16_t sk[KYBER_K][KYBER_N], const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES]) {
+    polyvec_frombytes(sk, packedsk);
 }
 
 /*************************************************
@@ -124,10 +122,9 @@
 *              poly *pk: pointer to the input vector of polynomials b
 *              poly *v: pointer to the input polynomial v
 **************************************************/
-static void pack_ciphertext(uint8_t r[KYBER_INDCPA_BYTES], int16_t b[KYBER_K][KYBER_N], int16_t *v)
-{
-  polyvec_compress(r, b);
-  poly_compress(r+KYBER_POLYVECCOMPRESSEDBYTES, v);
+static void pack_ciphertext(uint8_t r[KYBER_INDCPA_BYTES], int16_t b[KYBER_K][KYBER_N], int16_t *v) {
+    polyvec_compress(r, b);
+    poly_compress(r + KYBER_POLYVECCOMPRESSEDBYTES, v);
 }
 
 /*************************************************
@@ -140,10 +137,9 @@
 *              - poly *v: pointer to the output polynomial v
 *              - const uint8_t *c: pointer to the input serialized ciphertext
 **************************************************/
-static void unpack_ciphertext(int16_t b[KYBER_K][KYBER_N], int16_t *v, const uint8_t c[KYBER_INDCPA_BYTES])
-{
-  polyvec_decompress(b, c);
-  poly_decompress(v, c+KYBER_POLYVECCOMPRESSEDBYTES);
+static void unpack_ciphertext(int16_t b[KYBER_K][KYBER_N], int16_t *v, const uint8_t c[KYBER_INDCPA_BYTES]) {
+    polyvec_decompress(b, c);
+    poly_decompress(v, c + KYBER_POLYVECCOMPRESSEDBYTES);
 }
 
 
@@ -164,175 +160,163 @@
 **************************************************/
 #define GEN_MATRIX_NBLOCKS ((12*KYBER_N/8*(1 << 12)/KYBER_Q + XOF_BLOCKBYTES)/XOF_BLOCKBYTES)
 // Not static for benchmarking
-void gen_matrix(int16_t a[KYBER_K][KYBER_K][KYBER_N], const uint8_t seed[KYBER_SYMBYTES], int transposed)
-{
-  unsigned int ctr0, ctr1, k;
-  unsigned int buflen, off;
-  uint8_t buf0[GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES + 2],
-      buf1[GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES + 2];
-  neon_xof_state state;
-
-#if KYBER_K == 2
-  for (unsigned int i = 0; i < KYBER_K; i++)
-  {
-    if (transposed)
-      neon_xof_absorb(&state, seed, i, i, 0, 1);
-    else
-      neon_xof_absorb(&state, seed, 0, 1, i, i);
+void gen_matrix(int16_t a[KYBER_K][KYBER_K][KYBER_N], const uint8_t seed[KYBER_SYMBYTES], int transposed) {
+    unsigned int ctr0, ctr1, k;
+    unsigned int buflen, off;
+    uint8_t buf0[GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES + 2],
+            buf1[GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES + 2];
+    neon_xof_state state;
+
+    #if KYBER_K == 2
+    for (unsigned int i = 0; i < KYBER_K; i++) {
+        if (transposed) {
+            neon_xof_absorb(&state, seed, i, i, 0, 1);
+        } else {
+            neon_xof_absorb(&state, seed, 0, 1, i, i);
+        }
 
-    neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
+        neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
 
-    buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
+        buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
 
-    ctr0 = neon_rej_uniform(&(a[i][0][0]), buf0);
-    ctr1 = neon_rej_uniform(&(a[i][1][0]), buf1);
-    while (ctr0 < KYBER_N || ctr1 < KYBER_N)
-    {
-      off = buflen % 3;
-      for (k = 0; k < off; k++)
-      {
-        buf0[k] = buf0[buflen - off + k];
-        buf1[k] = buf1[buflen - off + k];
-      }
-      neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
-
-      buflen = off + XOF_BLOCKBYTES;
-      ctr0 += rej_uniform(&(a[i][0][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
-      ctr1 += rej_uniform(&(a[i][1][0]) + ctr1, KYBER_N - ctr1, buf1, buflen);
-    }
-  }
-#elif KYBER_K == 3
-  int16_t *s1 = NULL, *s2 = NULL;
-  unsigned int x1, x2, y1, y2;
-  xof_state c_state;
-
-  for (unsigned int j = 0; j < KYBER_K * KYBER_K - 1; j += 2)
-  {
-    switch (j)
-    {
-    case 0:
-      s1 = &(a[0][0][0]);
-      s2 = &(a[0][1][0]);
-      x1 = 0;
-      y1 = 0;
-      x2 = 0;
-      y2 = 1;
-      break;
-    case 2:
-      s1 = &(a[0][2][0]);
-      s2 = &(a[1][0][0]);
-      x1 = 0;
-      y1 = 2;
-      x2 = 1;
-      y2 = 0;
-      break;
-    case 4:
-      s1 = &(a[1][1][0]);
-      s2 = &(a[1][2][0]);
-      x1 = 1;
-      y1 = 1;
-      x2 = 1;
-      y2 = 2;
-      break;
-    default:
-      s1 = &(a[2][0][0]);
-      s2 = &(a[2][1][0]);
-      x1 = 2;
-      y1 = 0;
-      x2 = 2;
-      y2 = 1;
-      break;
-    }
-
-    if (transposed)
-      neon_xof_absorb(&state, seed, x1, x2, y1, y2);
-    else
-      neon_xof_absorb(&state, seed, y1, y2, x1, x2);
+        ctr0 = neon_rej_uniform(&(a[i][0][0]), buf0);
+        ctr1 = neon_rej_uniform(&(a[i][1][0]), buf1);
+        while (ctr0 < KYBER_N || ctr1 < KYBER_N) {
+            off = buflen % 3;
+            for (k = 0; k < off; k++) {
+                buf0[k] = buf0[buflen - off + k];
+                buf1[k] = buf1[buflen - off + k];
+            }
+            neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
+
+            buflen = off + XOF_BLOCKBYTES;
+            ctr0 += rej_uniform(&(a[i][0][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
+            ctr1 += rej_uniform(&(a[i][1][0]) + ctr1, KYBER_N - ctr1, buf1, buflen);
+        }
+    }
+    #elif KYBER_K == 3
+    int16_t *s1 = NULL, *s2 = NULL;
+    unsigned int x1, x2, y1, y2;
+    xof_state c_state;
+
+    for (unsigned int j = 0; j < KYBER_K * KYBER_K - 1; j += 2) {
+        switch (j) {
+        case 0:
+            s1 = &(a[0][0][0]);
+            s2 = &(a[0][1][0]);
+            x1 = 0;
+            y1 = 0;
+            x2 = 0;
+            y2 = 1;
+            break;
+        case 2:
+            s1 = &(a[0][2][0]);
+            s2 = &(a[1][0][0]);
+            x1 = 0;
+            y1 = 2;
+            x2 = 1;
+            y2 = 0;
+            break;
+        case 4:
+            s1 = &(a[1][1][0]);
+            s2 = &(a[1][2][0]);
+            x1 = 1;
+            y1 = 1;
+            x2 = 1;
+            y2 = 2;
+            break;
+        default:
+            s1 = &(a[2][0][0]);
+            s2 = &(a[2][1][0]);
+            x1 = 2;
+            y1 = 0;
+            x2 = 2;
+            y2 = 1;
+            break;
+        }
 
-    neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
+        if (transposed) {
+            neon_xof_absorb(&state, seed, x1, x2, y1, y2);
+        } else {
+            neon_xof_absorb(&state, seed, y1, y2, x1, x2);
+        }
 
-    buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
+        neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
+
+        buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
+
+        ctr0 = neon_rej_uniform(s1, buf0);
+        ctr1 = neon_rej_uniform(s2, buf1);
+
+        while (ctr0 < KYBER_N || ctr1 < KYBER_N) {
+            off = buflen % 3;
+            for (k = 0; k < off; k++) {
+                buf0[k] = buf0[buflen - off + k];
+                buf1[k] = buf1[buflen - off + k];
+            }
+            neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
+
+            buflen = off + XOF_BLOCKBYTES;
+            ctr0 += rej_uniform(s1 + ctr0, KYBER_N - ctr0, buf0, buflen);
+            ctr1 += rej_uniform(s2 + ctr1, KYBER_N - ctr1, buf1, buflen);
+        }
+    }
+
+    // Last iteration [2][2]
+    if (transposed) {
+        xof_absorb(&c_state, seed, 2, 2);
+    } else {
+        xof_absorb(&c_state, seed, 2, 2);
+    }
+
+    xof_squeezeblocks(buf0, GEN_MATRIX_NBLOCKS, &c_state);
 
-    ctr0 = neon_rej_uniform(s1, buf0);
-    ctr1 = neon_rej_uniform(s2, buf1);
+    buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
 
-    while (ctr0 < KYBER_N || ctr1 < KYBER_N)
-    {
-      off = buflen % 3;
-      for (k = 0; k < off; k++)
-      {
-        buf0[k] = buf0[buflen - off + k];
-        buf1[k] = buf1[buflen - off + k];
-      }
-      neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
-
-      buflen = off + XOF_BLOCKBYTES;
-      ctr0 += rej_uniform(s1 + ctr0, KYBER_N - ctr0, buf0, buflen);
-      ctr1 += rej_uniform(s2 + ctr1, KYBER_N - ctr1, buf1, buflen);
-    }
-  }
-
-  // Last iteration [2][2]
-  if (transposed){
-    xof_absorb(&c_state, seed, 2, 2);
-  }
-  else{
-    xof_absorb(&c_state, seed, 2, 2);
-  }
-
-  xof_squeezeblocks(buf0, GEN_MATRIX_NBLOCKS, &c_state);
-
-  buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
-
-  ctr0 = neon_rej_uniform(&(a[2][2][0]), buf0);
-
-  while (ctr0 < KYBER_N)
-  {
-    off = buflen % 3;
-    for (k = 0; k < off; k++)
-    {
-      buf0[k] = buf0[buflen - off + k];
-    }
-    xof_squeezeblocks(buf0 + off, 1, &c_state);
-
-    buflen = off + XOF_BLOCKBYTES;
-    ctr0 += rej_uniform(&(a[2][2][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
-  }
-
-#elif KYBER_K == 4
-  for (unsigned int i = 0; i < KYBER_K; i++)
-  {
-    for (unsigned int j = 0; j < KYBER_K; j += 2)
-    {
-      if (transposed)
-        neon_xof_absorb(&state, seed, i, i, j, j + 1);
-      else
-        neon_xof_absorb(&state, seed, j, j + 1, i, i);
-
-      neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
-      buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
-      ctr0 = neon_rej_uniform(&(a[i][j][0]), buf0);
-      ctr1 = neon_rej_uniform(&(a[i][j + 1][0]), buf1);
+    ctr0 = neon_rej_uniform(&(a[2][2][0]), buf0);
 
-      while (ctr0 < KYBER_N || ctr1 < KYBER_N)
-      {
+    while (ctr0 < KYBER_N) {
         off = buflen % 3;
-        for (k = 0; k < off; k++)
-        {
-          buf0[k] = buf0[buflen - off + k];
-          buf1[k] = buf1[buflen - off + k];
+        for (k = 0; k < off; k++) {
+            buf0[k] = buf0[buflen - off + k];
         }
-        neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
+        xof_squeezeblocks(buf0 + off, 1, &c_state);
 
         buflen = off + XOF_BLOCKBYTES;
-        ctr0 += rej_uniform(&(a[i][j][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
-        ctr1 += rej_uniform(&(a[i][j + 1][0]) + ctr1, KYBER_N - ctr1, buf1, buflen);
-      }
+        ctr0 += rej_uniform(&(a[2][2][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
     }
-  }
-#else
+    shake128_ctx_release(&c_state);
+
+    #elif KYBER_K == 4
+    for (unsigned int i = 0; i < KYBER_K; i++) {
+        if (transposed) {
+            neon_xof_absorb(&state, seed, i, i, 0, 1);
+        } else {
+            neon_xof_absorb(&state, seed, 0, 1, i, i);
+        }
+
+        neon_xof_squeezeblocks(buf0, buf1, GEN_MATRIX_NBLOCKS, &state);
+
+        buflen = GEN_MATRIX_NBLOCKS * XOF_BLOCKBYTES;
+
+        ctr0 = neon_rej_uniform(&(a[i][0][0]), buf0);
+        ctr1 = neon_rej_uniform(&(a[i][1][0]), buf1);
+        while (ctr0 < KYBER_N || ctr1 < KYBER_N) {
+            off = buflen % 3;
+            for (k = 0; k < off; k++) {
+                buf0[k] = buf0[buflen - off + k];
+                buf1[k] = buf1[buflen - off + k];
+            }
+            neon_xof_squeezeblocks(buf0 + off, buf1 + off, 1, &state);
+
+            buflen = off + XOF_BLOCKBYTES;
+            ctr0 += rej_uniform(&(a[i][0][0]) + ctr0, KYBER_N - ctr0, buf0, buflen);
+            ctr1 += rej_uniform(&(a[i][1][0]) + ctr1, KYBER_N - ctr1, buf1, buflen);
+        }
+    }
+    #else
 #error "KYBER_K must be in {2,3,4}"
-#endif
+    #endif
 }
 
 /*************************************************
@@ -347,12 +331,11 @@
                               (of length KYBER_INDCPA_SECRETKEYBYTES bytes)
 **************************************************/
 void indcpa_keypair(uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
-                    uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES])
-{
+                    uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES]) {
     unsigned int i;
-    uint8_t buf[2*KYBER_SYMBYTES];
+    uint8_t buf[2 * KYBER_SYMBYTES];
     const uint8_t *publicseed = buf;
-    const uint8_t *noiseseed = buf+KYBER_SYMBYTES;
+    const uint8_t *noiseseed = buf + KYBER_SYMBYTES;
     int16_t a[KYBER_K][KYBER_K][KYBER_N];
     int16_t e[KYBER_K][KYBER_N];
     int16_t pkpv[KYBER_K][KYBER_N];
@@ -364,29 +347,29 @@
 
     gen_a(a, publicseed);
 
-#if KYBER_K == 2
-  neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
-  neon_poly_getnoise_eta1_2x(&(e[0][0]), &(e[1][0]), noiseseed, 2, 3);
-#elif KYBER_K == 3
-  neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
-  neon_poly_getnoise_eta1_2x(&(skpv[2][0]), &(e[0][0]), noiseseed, 2, 3);
-  neon_poly_getnoise_eta1_2x(&(e[1][0]), &(e[2][0]), noiseseed, 4, 5);
-#elif KYBER_K == 4
-  neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
-  neon_poly_getnoise_eta1_2x(&(skpv[2][0]), &(skpv[3][0]), noiseseed, 2, 3);
-  neon_poly_getnoise_eta1_2x(&(e[0][0]), &(e[1][0]), noiseseed, 4, 5);
-  neon_poly_getnoise_eta1_2x(&(e[2][0]), &(e[3][0]), noiseseed, 6, 7);
-#endif
+    #if KYBER_K == 2
+    neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
+    neon_poly_getnoise_eta1_2x(&(e[0][0]), &(e[1][0]), noiseseed, 2, 3);
+    #elif KYBER_K == 3
+    neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
+    neon_poly_getnoise_eta1_2x(&(skpv[2][0]), &(e[0][0]), noiseseed, 2, 3);
+    neon_poly_getnoise_eta1_2x(&(e[1][0]), &(e[2][0]), noiseseed, 4, 5);
+    #elif KYBER_K == 4
+    neon_poly_getnoise_eta1_2x(&(skpv[0][0]), &(skpv[1][0]), noiseseed, 0, 1);
+    neon_poly_getnoise_eta1_2x(&(skpv[2][0]), &(skpv[3][0]), noiseseed, 2, 3);
+    neon_poly_getnoise_eta1_2x(&(e[0][0]), &(e[1][0]), noiseseed, 4, 5);
+    neon_poly_getnoise_eta1_2x(&(e[2][0]), &(e[3][0]), noiseseed, 6, 7);
+    #endif
 
     neon_polyvec_ntt(skpv);
     neon_polyvec_ntt(e);
 
-    for(i = 0; i < KYBER_K; i++){
-        __asm_point_mul_extended(&(skpv_asymmetric[i][0]), &(skpv[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
+    for (i = 0; i < KYBER_K; i++) {
+        PQCLEAN_NAMESPACE__asm_point_mul_extended(&(skpv_asymmetric[i][0]), &(skpv[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
     }
 
-    for(i = 0; i < KYBER_K; i++){
-        __asm_asymmetric_mul_montgomery(&(a[i][0][0]), &(skpv[0][0]), &(skpv_asymmetric[0][0]), asymmetric_const, pkpv[i]);
+    for (i = 0; i < KYBER_K; i++) {
+        PQCLEAN_NAMESPACE__asm_asymmetric_mul_montgomery(&(a[i][0][0]), &(skpv[0][0]), &(skpv_asymmetric[0][0]), asymmetric_const, pkpv[i]);
     }
 
     neon_polyvec_add_reduce(pkpv, e);
@@ -415,8 +398,7 @@
 void indcpa_enc(uint8_t c[KYBER_INDCPA_BYTES],
                 const uint8_t m[KYBER_INDCPA_MSGBYTES],
                 const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
-                const uint8_t coins[KYBER_SYMBYTES])
-{
+                const uint8_t coins[KYBER_SYMBYTES]) {
     unsigned int i;
     uint8_t seed[KYBER_SYMBYTES];
     int16_t at[KYBER_K][KYBER_K][KYBER_N];
@@ -433,44 +415,44 @@
     poly_frommsg(k, m);
     gen_at(at, seed);
 
-#if KYBER_K == 2
+    #if KYBER_K == 2
   // ETA1 != ETA2 (3 != 2)
   neon_poly_getnoise_eta1_2x(&(sp[0][0]), &(sp[1][0]), coins, 0, 1);
   neon_poly_getnoise_eta2_2x(&(ep[0][0]), &(ep[1][0]), coins, 2, 3);
   neon_poly_getnoise_eta2(&(epp[0]), coins, 4);
-#elif KYBER_K == 3
-#if KYBER_ETA1 == KYBER_ETA2
-  // Because ETA1 == ETA2
-  neon_poly_getnoise_eta1_2x(&(sp[0][0]), &(sp[1][0]), coins, 0, 1);
-  neon_poly_getnoise_eta1_2x(&(sp[2][0]), &(ep[0][0]), coins, 2, 3);
-  neon_poly_getnoise_eta1_2x(&(ep[1][0]), &(ep[2][0]), coins, 4, 5);
-  neon_poly_getnoise_eta2(&(epp[0]), coins, 6);
-#else
+    #elif KYBER_K == 3
+    #if KYBER_ETA1 == KYBER_ETA2
+    // Because ETA1 == ETA2
+    neon_poly_getnoise_eta1_2x(&(sp[0][0]), &(sp[1][0]), coins, 0, 1);
+    neon_poly_getnoise_eta1_2x(&(sp[2][0]), &(ep[0][0]), coins, 2, 3);
+    neon_poly_getnoise_eta1_2x(&(ep[1][0]), &(ep[2][0]), coins, 4, 5);
+    neon_poly_getnoise_eta2(&(epp[0]), coins, 6);
+    #else
 #error "We need eta1 == eta2 here"
-#endif
-#elif KYBER_K == 4
-#if KYBER_ETA1 == KYBER_ETA2
-  neon_poly_getnoise_eta1_2x(&(sp[0][0]), &(sp[1][0]), coins, 0, 1);
-  neon_poly_getnoise_eta1_2x(&(sp[2][0]), &(sp[3][0]), coins, 2, 3);
-  neon_poly_getnoise_eta1_2x(&(ep[0][0]), &(ep[1][0]), coins, 4, 5);
-  neon_poly_getnoise_eta1_2x(&(ep[2][0]), &(ep[3][0]), coins, 6, 7);
-  neon_poly_getnoise_eta2(&(epp[0]), coins, 8);
-#else
+    #endif
+    #elif KYBER_K == 4
+    #if KYBER_ETA1 == KYBER_ETA2
+    neon_poly_getnoise_eta1_2x(&(sp[0][0]), &(sp[1][0]), coins, 0, 1);
+    neon_poly_getnoise_eta1_2x(&(sp[2][0]), &(sp[3][0]), coins, 2, 3);
+    neon_poly_getnoise_eta1_2x(&(ep[0][0]), &(ep[1][0]), coins, 4, 5);
+    neon_poly_getnoise_eta1_2x(&(ep[2][0]), &(ep[3][0]), coins, 6, 7);
+    neon_poly_getnoise_eta2(&(epp[0]), coins, 8);
+    #else
 #error "We need eta1 == eta2 here"
-#endif
-#endif
+    #endif
+    #endif
 
     neon_polyvec_ntt(sp);
 
     for(i = 0; i < KYBER_K; i++){
-        __asm_point_mul_extended(&(sp_asymmetric[i][0]), &(sp[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
+        PQCLEAN_NAMESPACE__asm_point_mul_extended(&(sp_asymmetric[i][0]), &(sp[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
     }
 
     for(i = 0; i < KYBER_K; i++){
-        __asm_asymmetric_mul(&(at[i][0][0]), &(sp[0][0]), &(sp_asymmetric[0][0]), asymmetric_const, b[i]);
+        PQCLEAN_NAMESPACE__asm_asymmetric_mul(&(at[i][0][0]), &(sp[0][0]), &(sp_asymmetric[0][0]), asymmetric_const, b[i]);
     }
 
-    __asm_asymmetric_mul(&(pkpv[0][0]), &(sp[0][0]), &(sp_asymmetric[0][0]), asymmetric_const, v);
+    PQCLEAN_NAMESPACE__asm_asymmetric_mul(&(pkpv[0][0]), &(sp[0][0]), &(sp_asymmetric[0][0]), asymmetric_const, v);
 
     neon_polyvec_invntt_to_mont(b);
     invntt(v);
@@ -497,11 +479,10 @@
 **************************************************/
 void indcpa_dec(uint8_t m[KYBER_INDCPA_MSGBYTES],
                 const uint8_t c[KYBER_INDCPA_BYTES],
-                const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES])
-{
+                const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES]) {
     unsigned int i;
     int16_t b[KYBER_K][KYBER_N];
-    int16_t b_asymmetric[KYBER_K][KYBER_N >>1];
+    int16_t b_asymmetric[KYBER_K][KYBER_N >> 1];
     int16_t skpv[KYBER_K][KYBER_N];
     int16_t v[KYBER_N];
     int16_t mp[KYBER_N];
@@ -512,11 +493,11 @@
 
     neon_polyvec_ntt(b);
 
-    for(i = 0; i < KYBER_K; i++){
-        __asm_point_mul_extended(&(b_asymmetric[i][0]), &(b[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
+    for (i = 0; i < KYBER_K; i++) {
+        PQCLEAN_NAMESPACE__asm_point_mul_extended(&(b_asymmetric[i][0]), &(b[i][0]), pre_asymmetric_table_Q1_extended, asymmetric_const);
     }
 
-    __asm_asymmetric_mul(&(skpv[0][0]), &(b[0][0]), &(b_asymmetric[0][0]), asymmetric_const, mp);
+    PQCLEAN_NAMESPACE__asm_asymmetric_mul(&(skpv[0][0]), &(b[0][0]), &(b_asymmetric[0][0]), asymmetric_const, mp);
 
     invntt(mp);
 

