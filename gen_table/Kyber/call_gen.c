
/*
 * CC0 1.0 Universal or the following MIT License
 *
 * MIT License
 *
 * Copyright (c) 2024: Vincent Hwang
 * Copyright (c) 2023: Vincent Hwang
 * Copyright (c) 2023: Hanno Becker, Vincent Hwang, Matthias J. Kannwischer, Bo-Yin Yang, and Shang-Yi Yang
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <assert.h>

#include "NTT_params.h"
#include "gen_table.h"
#include "tools.h"

#define BUFF_MAX (NTT_N << 4)

struct compress_profile profile;

static const int16_t streamlined_CT_negacyclic_table_jump_extended[((NTT_N - 1) + (1 << 0) + (1 << 4) + NTT_N) << 1] = {
0, 0, -1600, -15749, -749, -7373, -40, -394, -687, -6762, 630, 6201, -1432, -14095, 848, 8347, 1062, 10453, -1410, -13879, 193, 1900, 797, 7845, -543, -5345, -69, -679, 569, 5601, -1583, -15582, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 296, 296, 1426, 1426, -882, -882, -1235, -1235, 2914, 2914, 14036, 14036, -8682, -8682, -12156, -12156, 289, 289, -1010, -1010, -76, -76, 807, 807, 2845, 2845, -9942, -9942, -748, -748, 7943, 7943, 331, 331, 1435, 1435, -1573, -1573, 452, 452, 3258, 3258, 14125, 14125, -15483, -15483, 4449, 4449, 17, 17, 1584, 1584, 1637, 1637, 375, 375, 167, 167, 15592, 15592, 16113, 16113, 3691, 3691, -568, -568, -1031, -1031, 723, 723, -780, -780, -5591, -5591, -10148, -10148, 7117, 7117, -7678, -7678, 583, 583, -1292, -1292, -1041, -1041, -1239, -1239, 5739, 5739, -12717, -12717, -10247, -10247, -12196, -12196, -680, -680, -109, -109, 1100, 1100, 1645, 1645, -6693, -6693, -1073, -1073, 10828, 10828, 16192, 16192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 1339, 535, 535, 1476, 1476, -447, -447, 13180, 13180, 5266, 5266, 14529, 14529, -4400, -4400, 1197, 1197, 1438, 1438, -1052, -1052, 1534, 1534, 11782, 11782, 14155, 14155, -10355, -10355, 15099, 15099, -1025, -1025, -461, -461, -1274, -1274, -927, -927, -10089, -10089, -4538, -4538, -12540, -12540, -9125, -9125, 1409, 1409, 1063, 1063, 756, 756, -1230, -1230, 13869, 13869, 10463, 10463, 7441, 7441, -12107, -12107, -667, -667, 319, 319, -1173, -1173, 561, 561, -6565, -6565, 3140, 3140, -11546, -11546, 5522, 5522, -48, -48, -556, -556, -314, -314, -863, -863, -472, -472, -5473, -5473, -3091, -3091, -8495, -8495, 233, 233, 757, 757, -279, -279, -735, -735, 2293, 2293, 7451, 7451, -2746, -2746, -7235, -7235, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -283, -283, -936, -936, 56, 56, -450, -450, -2786, -2786, -9213, -9213, 551, 551, -4429, -4429, 650, 650, -682, -682, -816, -816, 1481, 1481, 6398, 6398, -6713, -6713, -8032, -8032, 14578, 14578, -1352, -1352, -712, -712, 632, 632, 648, 648, -13308, -13308, -7008, -7008, 6221, 6221, 6378, 6378, -1626, -1626, -525, -525, -1482, -1482, 1143, 1143, -16005, -16005, -5168, -5168, -14588, -14588, 11251, 11251, 1651, 1651, 1092, 1092, 952, 952, -1179, -1179, 16251, 16251, 10749, 10749, 9371, 9371, -11605, -11605, -540, -540, 403, 403, 1461, 1461, -554, -554, -5315, -5315, 3967, 3967, 14381, 14381, -5453, -5453, -1540, -1540, 1026, 1026, -642, -642, 886, 886, -15159, -15159, 10099, 10099, -6319, -6319, 8721, 8721, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1089, -1089, -1355, -1355, 1333, 1333, 821, 821, -10719, -10719, -13338, -13338, 13121, 13121, 8081, 8081, -464, -464, -855, -855, 1320, 1320, 1227, 1227, -4567, -4567, -8416, -8416, 12993, 12993, 12078, 12078, 33, 33, -219, -219, -1414, -1414, 910, 910, 325, 325, -2156, -2156, -13918, -13918, 8957, 8957, 939, 939, -1607, -1607, 733, 733, -1219, -1219, 9243, 9243, -15818, -15818, 7215, 7215, -11999, -11999, -1021, -1021, 1212, 1212, -992, -992, -394, -394, -10050, -10050, 11930, 11930, -9764, -9764, -3878, -3878, -892, -892, -1455, -1455, 268, 268, 885, 885, -8780, -8780, -14322, -14322, 2638, 2638, 8711, 8711, -941, -941, 1029, 1029, 641, 641, -1175, -1175, -9262, -9262, 10129, 10129, 6309, 6309, -11566, -11566
};

static const int16_t pre_asymmetric_table_Q1_extended[ARRAY_N] = {
17, -17, -568, 568, 583, -583, -680, 680, 167, -167, -5591, 5591, 5739, -5739, -6693, 6693, 1637, -1637, 723, -723, -1041, 1041, 1100, -1100, 16113, -16113, 7117, -7117, -10247, 10247, 10828, -10828, 1409, -1409, -667, 667, -48, 48, 233, -233, 13869, -13869, -6565, 6565, -472, 472, 2293, -2293, 756, -756, -1173, 1173, -314, 314, -279, 279, 7441, -7441, -11546, 11546, -3091, 3091, -2746, 2746, -1626, 1626, 1651, -1651, -540, 540, -1540, 1540, -16005, 16005, 16251, -16251, -5315, 5315, -15159, 15159, -1482, 1482, 952, -952, 1461, -1461, -642, 642, -14588, 14588, 9371, -9371, 14381, -14381, -6319, 6319, 939, -939, -1021, 1021, -892, 892, -941, 941, 9243, -9243, -10050, 10050, -8780, 8780, -9262, 9262, 733, -733, -992, 992, 268, -268, 641, -641, 7215, -7215, -9764, 9764, 2638, -2638, 6309, -6309, 1584, -1584, -1031, 1031, -1292, 1292, -109, 109, 15592, -15592, -10148, 10148, -12717, 12717, -1073, 1073, 375, -375, -780, 780, -1239, 1239, 1645, -1645, 3691, -3691, -7678, 7678, -12196, 12196, 16192, -16192, 1063, -1063, 319, -319, -556, 556, 757, -757, 10463, -10463, 3140, -3140, -5473, 5473, 7451, -7451, -1230, 1230, 561, -561, -863, 863, -735, 735, -12107, 12107, 5522, -5522, -8495, 8495, -7235, 7235, -525, 525, 1092, -1092, 403, -403, 1026, -1026, -5168, 5168, 10749, -10749, 3967, -3967, 10099, -10099, 1143, -1143, -1179, 1179, -554, 554, 886, -886, 11251, -11251, -11605, 11605, -5453, 5453, 8721, -8721, -1607, 1607, 1212, -1212, -1455, 1455, 1029, -1029, -15818, 15818, 11930, -11930, -14322, 14322, 10129, -10129, -1219, 1219, -394, 394, 885, -885, -1175, 1175, -11999, 11999, -3878, 3878, 8711, -8711, -11566, 11566
};

static const int16_t streamlined_inv_GS_negacyclic_table_jump_extended[((NTT_N - 1) + (1 << 0) + (1 << 4) + NTT_N) << 1] = {
0, 0, 1600, 15749, 40, 394, 749, 7373, -848, -8347, 1432, 14095, -630, -6201, 687, 6762, 1583, 15582, -569, -5601, 69, 679, 543, 5345, -797, -7845, -193, -1900, 1410, 13879, -1062, -10453, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -821, -821, -1333, -1333, 1355, 1355, 1089, 1089, -8081, -8081, -13121, -13121, 13338, 13338, 10719, 10719, -910, -910, 1414, 1414, 219, 219, -33, -33, -8957, -8957, 13918, 13918, 2156, 2156, -325, -325, -1227, -1227, -1320, -1320, 855, 855, 464, 464, -12078, -12078, -12993, -12993, 8416, 8416, 4567, 4567, 1175, 1175, -641, -641, -1029, -1029, 941, 941, 11566, 11566, -6309, -6309, -10129, -10129, 9262, 9262, -885, -885, -268, -268, 1455, 1455, 892, 892, -8711, -8711, -2638, -2638, 14322, 14322, 8780, 8780, 394, 394, 992, 992, -1212, -1212, 1021, 1021, 3878, 3878, 9764, 9764, -11930, -11930, 10050, 10050, 1219, 1219, -733, -733, 1607, 1607, -939, -939, 11999, 11999, -7215, -7215, 15818, 15818, -9243, -9243, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 450, 450, -56, -56, 936, 936, 283, 283, 4429, 4429, -551, -551, 9213, 9213, 2786, 2786, -648, -648, -632, -632, 712, 712, 1352, 1352, -6378, -6378, -6221, -6221, 7008, 7008, 13308, 13308, -1481, -1481, 816, 816, 682, 682, -650, -650, -14578, -14578, 8032, 8032, 6713, 6713, -6398, -6398, -886, -886, 642, 642, -1026, -1026, 1540, 1540, -8721, -8721, 6319, 6319, -10099, -10099, 15159, 15159, 554, 554, -1461, -1461, -403, -403, 540, 540, 5453, 5453, -14381, -14381, -3967, -3967, 5315, 5315, 1179, 1179, -952, -952, -1092, -1092, -1651, -1651, 11605, 11605, -9371, -9371, -10749, -10749, -16251, -16251, -1143, -1143, 1482, 1482, 525, 525, 1626, 1626, -11251, -11251, 14588, 14588, 5168, 5168, 16005, 16005, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 447, 447, -1476, -1476, -535, -535, -1339, -1339, 4400, 4400, -14529, -14529, -5266, -5266, -13180, -13180, 927, 927, 1274, 1274, 461, 461, 1025, 1025, 9125, 9125, 12540, 12540, 4538, 4538, 10089, 10089, -1534, -1534, 1052, 1052, -1438, -1438, -1197, -1197, -15099, -15099, 10355, 10355, -14155, -14155, -11782, -11782, 735, 735, 279, 279, -757, -757, -233, -233, 7235, 7235, 2746, 2746, -7451, -7451, -2293, -2293, 863, 863, 314, 314, 556, 556, 48, 48, 8495, 8495, 3091, 3091, 5473, 5473, 472, 472, -561, -561, 1173, 1173, -319, -319, 667, 667, -5522, -5522, 11546, 11546, -3140, -3140, 6565, 6565, 1230, 1230, -756, -756, -1063, -1063, -1409, -1409, 12107, 12107, -7441, -7441, -10463, -10463, -13869, -13869, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1235, 1235, 882, 882, -1426, -1426, -296, -296, 12156, 12156, 8682, 8682, -14036, -14036, -2914, -2914, -452, -452, 1573, 1573, -1435, -1435, -331, -331, -4449, -4449, 15483, 15483, -14125, -14125, -3258, -3258, -807, -807, 76, 76, 1010, 1010, -289, -289, -7943, -7943, 748, 748, 9942, 9942, -2845, -2845, -1645, -1645, -1100, -1100, 109, 109, 680, 680, -16192, -16192, -10828, -10828, 1073, 1073, 6693, 6693, 1239, 1239, 1041, 1041, 1292, 1292, -583, -583, 12196, 12196, 10247, 10247, 12717, 12717, -5739, -5739, 780, 780, -723, -723, 1031, 1031, 568, 568, 7678, 7678, -7117, -7117, 10148, 10148, 5591, 5591, -375, -375, -1637, -1637, -1584, -1584, -17, -17, -3691, -3691, -16113, -16113, -15592, -15592, -167, -167
};

void interleave(int16_t *des, int16_t *src0, int16_t *src1, int16_t *src2, int16_t *src3, size_t len);
void extend_table_int16(int16_t *table_extended, int16_t *table, size_t len, int16_t mod);
void extend_jump_table_int16(int16_t *table_extended, int16_t *table, size_t len, size_t jump, int16_t mod);

void uzp_2x8(int16_t *des);

int main(){

    int16_t buff[BUFF_MAX];
    int16_t buff_extended[BUFF_MAX];
    int16_t buff2[BUFF_MAX];

    int16_t scale_int16;
    int16_t omega_int16;
    int16_t mod_int16;

    int16_t *twiddle_ptr;

    profile.compressed_layers = 2;
    profile.merged_layers[0] = 4;
    profile.merged_layers[1] = 3;

// ================

    scale_int16 = 1;
    omega_int16 = omegaQ;
    mod_int16 = Q;
    gen_streamlined_CT_negacyclic_table_generic(
        buff,
        &scale_int16, &omega_int16,
        &mod_int16,
        sizeof(int16_t),
        mulmod_int16,
        &profile, 1
    );

    twiddle_ptr = buff + 16;
    for(size_t i = 0; i < 4; i++){
        interleave(buff2 + i * 32,
                   twiddle_ptr + 0 * 64 + 0 * 8 + i * 16,
                   twiddle_ptr + 1 * 64 + 0 * 8 + i * 16,
                   twiddle_ptr + 0 * 64 + 1 * 8 + i * 16,
                   twiddle_ptr + 1 * 64 + 1 * 8 + i * 16,
                   8);
    }

    for(size_t i = 0; i < 128; i++){
        twiddle_ptr[2 * i + 0] = twiddle_ptr[2 * i + 1] = buff2[i];
    }

    mod_int16 = Q;
    extend_table_int16(
        buff_extended,
        buff,
        (NTT_N - 1) + (1 << 0) + (1 << 4) + NTT_N,
        mod_int16
    );

    mod_int16 = Q;
    extend_jump_table_int16(
        buff_extended + 32,
        buff + 16,
        (NTT_N - 1) + (1 << 0) + NTT_N,
        8,
        mod_int16
    );

    for(size_t i = 0; i < (16 + 2 * NTT_N) * 2; i++){
        assert(streamlined_CT_negacyclic_table_jump_extended[i] == buff_extended[i]);
    }

// ================

// ================

    scale_int16 = omegaQ;
    mod_int16 = Q;
    omega_int16 = omegaQ;
    expmod_int16(&omega_int16, &omega_int16, 2, &mod_int16);
    gen_mul_table_generic(
        buff,
        &scale_int16, &omega_int16,
        &mod_int16,
        sizeof(int16_t),
        mulmod_int16
    );

    for(size_t i = 0; i < (NTT_N >> 1); i++){
        buff2[2 * i + 0] = buff[i];
        buff2[2 * i + 1] = -buff[i];
    }

    scale_int16 = 1;
    mod_int16 = Q;
    for(int i = 0; i < ARRAY_N >> 1; i++){
        mulmod_int16(buff2 + i, buff2 + i, &scale_int16, &mod_int16);
    }

    mod_int16 = Q;
    extend_table_int16(
        buff_extended,
        buff2,
        ARRAY_N >> 1,
        mod_int16
    );

    for(size_t i = 0; i < ARRAY_N; i += 16){
        uzp_2x8(buff_extended + i);
    }

    for(size_t i = 0; i < ARRAY_N; i++){
        assert(pre_asymmetric_table_Q1_extended[i] == buff_extended[i]);
    }

// ================

// ================

    scale_int16 = 1;
    omega_int16 = invomegaQ;
    mod_int16 = Q;
    gen_streamlined_CT_negacyclic_table_generic(
        buff,
        &scale_int16, &omega_int16,
        &mod_int16,
        sizeof(int16_t),
        mulmod_int16,
        &profile, 1
    );

    twiddle_ptr = buff + 16;
    for(size_t i = 0; i < 4; i++){
        interleave(buff2 + i * 32,
                   twiddle_ptr + 0 * 64 + 0 * 8 + i * 16,
                   twiddle_ptr + 1 * 64 + 0 * 8 + i * 16,
                   twiddle_ptr + 0 * 64 + 1 * 8 + i * 16,
                   twiddle_ptr + 1 * 64 + 1 * 8 + i * 16,
                   8);
    }

    for(size_t i = 0; i < 128; i++){
        twiddle_ptr[2 * i + 0] = twiddle_ptr[2 * i + 1] = buff2[i];
    }

    mod_int16 = Q;
    extend_table_int16(
        buff_extended,
        buff,
        (NTT_N - 1) + (1 << 0) + (1 << 4) + NTT_N,
        mod_int16
    );

    mod_int16 = Q;
    extend_jump_table_int16(
        buff_extended + 32,
        buff + 16,
        (NTT_N - 1) + (1 << 0) + NTT_N,
        8,
        mod_int16
    );

    for(size_t i = 0; i < (16 + 2 * NTT_N) * 2; i++){
        assert(streamlined_inv_GS_negacyclic_table_jump_extended[i] == buff_extended[i]);
    }

// ================

    printf("Table generation finished!\n");

}

void extend_table_int16(int16_t *table_extended, int16_t *table, size_t len, int16_t mod){

    int16_t table_v;
    int32_t B32;

    for(size_t i = 0; i < len; i++){
        table_v = table[i];

        B32 = (int32_t)table_v * (1 << 16);
        if(B32 < 0){
            B32 = -B32;
            B32 += mod;
            B32 = B32 / (2 * mod);
            B32 = -B32;
        }else{
            B32 += mod;
            B32 = B32 / (2 * mod);
        }

        table_extended[2 * i + 0] = table_v;
        table_extended[2 * i + 1] = B32;

    }

}

void extend_jump_table_int16(int16_t *table_extended, int16_t *table, size_t len, size_t jump, int16_t mod){

    int16_t tmp_extended[2 * len];

    extend_table_int16(tmp_extended, table, len, mod);

    for(size_t i = 0; i < 2 * len; i += 2 * jump){
        for(size_t j = 0; j < jump; j++){
            table_extended[i + j] = tmp_extended[i + 2 * j];
            table_extended[i + jump + j] = tmp_extended[i + 2 * j + 1];
        }
    }

}

void interleave(int16_t *des, int16_t *src0, int16_t *src1, int16_t *src2, int16_t *src3, size_t len){

    for(size_t i = 0; i < len; i++){
        des[4 * i + 0] = src0[i];
        des[4 * i + 1] = src1[i];
        des[4 * i + 2] = src2[i];
        des[4 * i + 3] = src3[i];
    }

}

void uzp_2x8(int16_t *des){

    int16_t buff[16];

    for(size_t i = 0; i < 8; i++){
        buff[i] = des[2 * i];
    }
    for(size_t i = 8; i < 16; i++){
        buff[i] = des[2 * (i - 8) + 1];
    }

    for(size_t i = 0; i < 16; i++){
        des[i] = buff[i];
    }

}




