--- work/saber/scheme/pack_unpack.c
+++ work-patched/saber/scheme/pack_unpack.c
@@ -1,9 +1,9 @@
 /*=============================================================================
-This file has been adapted from the implementation 
-(available at, Public Domain https://github.com/KULeuven-COSIC/SABER) 
+This file has been adapted from the implementation
+(available at, Public Domain https://github.com/KULeuven-COSIC/SABER)
 of "Saber: Module-LWR based key exchange, CPA-secure encryption and CCA-secure KEM"
 by : Jan-Pieter D'Anvers, Angshuman Karmakar, Sujoy Sinha Roy, and Frederik Vercauteren
-Jose Maria Bermudo Mera, Michiel Van Beirendonck, Andrea Basso. 
+Jose Maria Bermudo Mera, Michiel Van Beirendonck, Andrea Basso.
 =============================================================================*/
 
 
@@ -12,12 +12,11 @@
 #include <string.h>
 
 /* This function reduces its input mod T */
-void POLT2BS(uint8_t bytes[SABER_SCALEBYTES_KEM], const uint16_t data[SABER_N])
-{
+void POLT2BS(uint8_t bytes[SABER_SCALEBYTES_KEM], const uint16_t data[SABER_N]) {
     size_t j;
     const uint16_t *in = data;
     uint8_t *out = bytes;
-#if SABER_ET == 3 // LightSaber
+    #if SABER_ET == 3 // LightSaber
     for (j = 0; j < SABER_N / 8; j++) {
         out[0] = (uint8_t) ((in[0] & 0x7) | ((in[1] & 0x7) << 3) | (in[2] << 6));
         out[1] = (uint8_t) (((in[2] >> 2) & 0x01) | ((in[3] & 0x7) << 1) | ((in[4] & 0x7) << 4) | (in[5] << 7));
@@ -25,13 +24,13 @@
         in += 8;
         out += 3;
     }
-#elif SABER_ET == 4 // Saber
+    #elif SABER_ET == 4 // Saber
     for (j = 0; j < SABER_N / 2; j++) {
         out[0] = (uint8_t) ((in[0] & 0x0f) | (in[1] << 4));
         in += 2;
         out += 1;
     }
-#elif SABER_ET == 6 // FireSaber
+    #elif SABER_ET == 6 // FireSaber
     for (j = 0; j < SABER_N / 4; j++) {
         out[0] = (uint8_t) ((in[0] & 0x3f) | (in[1] << 6));
         out[1] = (uint8_t) (((in[1] >> 2) & 0x0f) | (in[2] << 4));
@@ -39,18 +38,17 @@
         in += 4;
         out += 3;
     }
-#else
+    #else
 #error "Unsupported SABER parameter."
-#endif
+    #endif
 }
 
 /* This function does NOT reduce its output mod T */
-void BS2POLT(const uint8_t bytes[SABER_SCALEBYTES_KEM], uint16_t data[SABER_N])
-{
+void BS2POLT(const uint8_t bytes[SABER_SCALEBYTES_KEM], uint16_t data[SABER_N]) {
+    #if SABER_ET == 3 // LightSaber
     size_t j;
     const uint8_t *in = bytes;
     uint16_t *out = data;
-#if SABER_ET == 3 // LightSaber
     for (j = 0; j < SABER_N / 8; j++) {
         out[0] = in[0];
         out[1] = in[0] >> 3;
@@ -63,9 +61,12 @@
         in += 3;
         out += 8;
     }
-#elif SABER_ET == 4 // Saber
-    __asm_4_to_16(&(data[0]), &(bytes[0]));
-#elif SABER_ET == 6 // FireSaber
+    #elif SABER_ET == 4 // Saber
+    PQCLEAN_NAMESPACE_asm_4_to_16(&(data[0]), &(bytes[0]));
+    #elif SABER_ET == 6 // FireSaber
+    size_t j;
+    const uint8_t *in = bytes;
+    uint16_t *out = data;
     for (j = 0; j < SABER_N / 4; j++) {
         out[0] = in[0];
         out[1] = (in[0] >> 6) | (in[1] << 2);
@@ -74,14 +75,13 @@
         in += 3;
         out += 4;
     }
-#else
+    #else
 #error "Unsupported SABER parameter."
-#endif
+    #endif
 }
 
 /* This function reduces its input mod q */
-void POLq2BS(uint8_t bytes[SABER_POLYBYTES], const uint16_t data[SABER_N])
-{
+void POLq2BS(uint8_t bytes[SABER_POLYBYTES], const uint16_t data[SABER_N]) {
     size_t i;
     const uint16_t *in = data;
     uint8_t *out = bytes;
@@ -106,8 +106,7 @@
 
 /* This function sign-extends its output from q-bit to 16-bit.
 This is needed by 16-bit NTTs */
-void BS2POLq(const uint8_t bytes[SABER_POLYBYTES], uint16_t data[SABER_N])
-{
+void BS2POLq(const uint8_t bytes[SABER_POLYBYTES], uint16_t data[SABER_N]) {
     size_t i;
     const uint8_t *in = bytes;
     int16_t *out = (int16_t *)data;
@@ -140,8 +139,7 @@
 }
 
 /* This function reduces its input mod p */
-void POLp2BS(uint8_t bytes[SABER_POLYCOMPRESSEDBYTES], const uint16_t data[SABER_N])
-{
+void POLp2BS(uint8_t bytes[SABER_POLYCOMPRESSEDBYTES], const uint16_t data[SABER_N]) {
     size_t i;
     const uint16_t *in = data;
     uint8_t *out = bytes;
@@ -158,8 +156,7 @@
 
 /* This function sign-extends its output from p-bit to 16-bit.
 This is needed by the NTT */
-void BS2POLp(const uint8_t bytes[SABER_POLYCOMPRESSEDBYTES], uint16_t data[SABER_N])
-{
+void BS2POLp(const uint8_t bytes[SABER_POLYCOMPRESSEDBYTES], uint16_t data[SABER_N]) {
     size_t j;
     const uint8_t *in = bytes;
     int16_t *out = (int16_t *)data;
@@ -183,49 +180,40 @@
     }
 }
 
-void POLVECq2BS(uint8_t bytes[SABER_POLYVECBYTES], const uint16_t data[SABER_L][SABER_N])
-{
-	size_t i;
-	for (i = 0; i < SABER_L; i++)
-	{
-		POLq2BS(bytes + i * SABER_POLYBYTES, data[i]);
-	}
-}
-
-void BS2POLVECq(const uint8_t bytes[SABER_POLYVECBYTES], uint16_t data[SABER_L][SABER_N])
-{
-	size_t i;
-	for (i = 0; i < SABER_L; i++)
-	{
-		BS2POLq(bytes + i * SABER_POLYBYTES, data[i]);
-	}
-}
-
-void POLVECp2BS(uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES], const uint16_t data[SABER_L][SABER_N])
-{
-	size_t i;
-	for (i = 0; i < SABER_L; i++)
-	{
-		POLp2BS(bytes + i * (SABER_EP * SABER_N / 8), data[i]);
-	}
-}
-
-void BS2POLVECp(const uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES], uint16_t data[SABER_L][SABER_N])
-{
-	size_t i;
-	for (i = 0; i < SABER_L; i++)
-	{
-		BS2POLp(bytes + i * (SABER_EP * SABER_N / 8), data[i]);
-	}
+void POLVECq2BS(uint8_t bytes[SABER_POLYVECBYTES], uint16_t data[SABER_L][SABER_N]) {
+    size_t i;
+    for (i = 0; i < SABER_L; i++) {
+        POLq2BS(bytes + i * SABER_POLYBYTES, data[i]);
+    }
+}
+
+void BS2POLVECq(const uint8_t bytes[SABER_POLYVECBYTES], uint16_t data[SABER_L][SABER_N]) {
+    size_t i;
+    for (i = 0; i < SABER_L; i++) {
+        BS2POLq(bytes + i * SABER_POLYBYTES, data[i]);
+    }
+}
+
+void POLVECp2BS(uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES], uint16_t data[SABER_L][SABER_N]) {
+    size_t i;
+    for (i = 0; i < SABER_L; i++) {
+        POLp2BS(bytes + i * (SABER_EP * SABER_N / 8), data[i]);
+    }
+}
+
+void BS2POLVECp(const uint8_t bytes[SABER_POLYVECCOMPRESSEDBYTES], uint16_t data[SABER_L][SABER_N]) {
+    size_t i;
+    for (i = 0; i < SABER_L; i++) {
+        BS2POLp(bytes + i * (SABER_EP * SABER_N / 8), data[i]);
+    }
 }
 
-void BS2POLmsg(const uint8_t bytes[SABER_KEYBYTES], uint16_t data[SABER_N]){
-    __asm_1_to_16(&(data[0]), &(bytes[0]));
+void BS2POLmsg(const uint8_t bytes[SABER_KEYBYTES], uint16_t data[SABER_N]) {
+    PQCLEAN_NAMESPACE_asm_1_to_16(&(data[0]), &(bytes[0]));
 }
 
 /* This function reduces its input mod 2 */
-void POLmsg2BS(uint8_t bytes[SABER_KEYBYTES], const uint16_t data[SABER_N])
-{
+void POLmsg2BS(uint8_t bytes[SABER_KEYBYTES], const uint16_t data[SABER_N]) {
     size_t i, j;
     uint8_t byte;
     for (j = 0; j < SABER_KEYBYTES; j++) {

